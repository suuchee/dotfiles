# CLAUDE.md

## 基本ポリシー

1. 回答は必ず日本語で行う。
2. 実装に入る前に、必ず下記を明確化・設計する。設計する場合は `Plan` モードに切り替える。
   * 目的・背景・前提条件
   * 全体設計
   * ブランチ戦略・ブランチ設計
   * コミット設計
3. 不明点や判断基準が曖昧な箇所は `AskUserQuestion` を使用して必ず質問し、クリアにしてから着手する。
4. 違和感・矛盾を見つけた場合は必ず報告する。
5. 常にあなたの知識は古い可能性があることを認識し、特に外部サービスやライブラリを利用しているコードの作成・変更を行う場合は、以下の手順で調査する。
   1. Context7または公式ドキュメントに直接アクセスし、最新仕様を確認
   2. 調査結果は実装根拠として `.workspace/context/<NNN>_<context-name>/research/<対象名>_YYYY-MM-DD.md` に保存
      * 一度保存した記録は過去の記録として価値があるため、メンテナンス不要
6. 対話中の要望や要件に関わる情報を常に `.workspace/context/<NNN>_<context-name>/requirements/requirements_YYYY-MM-DD.md` に記録する。
7. 検討したことは再度検討しなくていいよう `.workspace/context/<NNN>_<context-name>/deliberation/deliberation_YYYY-MM-DD.md` にメモする。

## .workspace/context

作業コンテキスト（ブランチ相当の作業単位）を管理するディレクトリ。
詳細は `~/.claude/rules/workspace-context.md` を参照。

## Git

### Git 初期化手順

```sh
git init
git branch -m main
git commit --allow-empty -m "first commit"
```

### ステージング

* 無関係の変更がコミットに入り込まないよう、必ずそのタスク内での変更ファイルのみを対象としてステージングすること。

### コミット

* コミット前に **現在のブランチを確認** し、適切なブランチにいるかを確認すること。
  * mainやmaster、developブランチや、変更内容とは異なるブランチの可能性がある場合は、新規でブランチの作成、または既存の適切なブランチへの移動を提案すること
* 一貫性のある履歴を残すため、**revert 可能な段階的コミット設計** を行う。
* 現在の状態を確認し、ブランチの設計も行う。
* コミット設計は以下をユーザーと確認する：
  * 変更範囲
  * コミット粒度
  * 不要ファイルの有無
* 未コミットの変更は **そのままにしておき** 、コミット時はそのタスク内で変更したファイルのみをコミットする.
* コミットメッセージは **`/git:conventions`** の規約に従う。
  * コミットメッセージは可能な限り、その変更の理由を記述する。
  * 日本語の場合は文章の途中に改行を入れないこと。
* Git管理下にあるファイルやディレクトリの名前の変更・移動は `git mv` コマンドを使うこと。

### amend

* ユーザーが明示的に amend を指示した場合のみ使用する。
* この会話内で作成したコミットであれば amend してよい（author 名ではなく会話の文脈で判断する）。
* リモートに push 済みのコミットは amend しない（force push が必要になるため）。

---

## GitHub

### GitHub CLI（gh コマンド）を基本とする

GitHub の操作は、可能な限り **gh コマンドで統一** する。

Issue も PR も **原則 gh を使う**。

### Issue ラベル

**詳細は `/github:labels` を参照。**

### PR レビュー基準

* 設計の妥当性
* 責務分離
* 破壊的変更の有無
* テストの有無

など

### PR 説明

* PRのbody（説明）を変更する場合は、現在の状態を確認してから編集お願いします。（CodeRabbit AIなどが編集している可能性があるため）

## 設計・実装ポリシー

### 優先順位

設計・実装の判断は以下の順で従う：

1. **プロジェクト固有のルール** - CLAUDE.md、コーディング規約、ADR など明文化されたもの
2. **既存コードベースのパターン** - 類似実装が既にあればそれに従う
3. **一般的なベストプラクティス** - 上記がない場合に適用

### コロケーション（Colocation）

関連するコードは近くに配置し、理解しやすく保守しやすい構造を維持する。

* 機能に必要なファイル（コンポーネント、スタイル、テスト、型定義、ユーティリティ）は同じディレクトリにまとめる
* 特定の機能でしか使わないものをグローバルな共通ディレクトリに置かない
* ディレクトリ構造を見ただけで、その機能の全体像が把握できる状態を目指す

### 共通化と再利用

実装前に既存資産を確認し、重複を避けて一貫性を保つ。

* **実装前の確認事項**
  * 既存のコンポーネント、ユーティリティ、型定義で流用できるものはないか
  * 類似の実装パターンがコードベースに存在しないか
* **計画段階での考慮**
  * 再利用可能な部品を特定し、計画に盛り込む
  * 共通化によるメリット（保守性、一貫性）とデメリット（過度な抽象化）を検討
* **新規作成時の判断基準**
  * 3箇所以上で使われる見込みがあれば共通化を検討
  * ただし、現時点で1箇所でしか使わないものを「将来のため」に共通化しない（YAGNI原則）
* **既存パターンの確認**
  * 類似の実装が既にあるか確認し、あればそのパターンに従う
  * なければ一般原則に従いつつ、周辺コードのスタイルを参考にする
  * 補助的に：ディレクトリ構成の一貫性、共通部品の整備状況も考慮
* **共通化のタイミング**
  * 共通化・リファクタリングは機能実装と混ぜず、別工程として行う
  * コミットまたはブランチを分け、変更の意図を明確にする

## 開発環境

### Python

* Python 仮想環境およびパッケージ管理は、uv を使用
* リンターおよびフォーマッターは、uv 同梱の ruff を使用
* ruff は、uv に同梱されているため、明示的な依存関係追加不要
* try-exception 内の logger は、 `logger.exception()` を使うようにしてください。

## Markdown

### テーブル

* 見出し行の区切りはハイフン3つ、両脇にスペースを入れた `| --- |` 形式を使用する（`:` によるアライメント指定は不要）
